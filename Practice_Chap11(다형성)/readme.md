## 다형성 (Polymorphism) @ 중요!!!
  * 여러가지 형태를 취하는 성질. 하나의 참조변수로 여러 타입의 객체를 참조하는 것
  * 조상 타입의 참조변수로 자손 타입의 객체를 참조할 수 있다
  * 그러나! 조상타입의 근본은 벗어나지 못한다
    - 조상클래스의 멤버에만 접근할 수 있다는 것.
    - 단, 메서드는 자손클래스에서 오버라이딩 되어있으면 자손클래스의 매서드가 호출됨.
    - 정리하자면, 멤버변수는 현재 참조변수의 타입을 따라감. 멤버메서드는 참조하고있는 인스턴스 타입의 영향을 받음(인스턴스에서 해당 멤버 메서드를 오버라이딩하고있다면 해당 메서드를 호출. 없으면 부모의 메서드를 호출)
  ### 현업에서는 멤버변수에 직접 접근하지 않고(캡슐화) getter와 같은 멤버 메서드를 이용해서 멤버변수의 값을 읽어오기 때문에 위와 같이 동작하는 것이 OOP의 특성을 더 잘 살리는 동작 방식이라고 볼 수 있을 듯 
    
## 다형성 왜 필요?
  * 여러타입의 객체를 하나의 타입으로 관리할 수 있음 => 코드의 재사용. 유지보수의 편리. 낮은 결합도.
  * 다형성을 통해 매개변수로 여러타입의 객체를 받을 수 있음
    - (ex) Product 클래스를 상속하는 TV, 세탁기, 에어컨의 클래스를 매개변수로 받는 함수에서 매개변수를 product 타입으로 받으면 TV, 세탁기, 에어컨을 매개변수로 받는 함수를 각각 처리하지 않아도 됨(코드의 재사용). 추후에 수정이 필요할 때도 함수 하나만 수정해주면 됨(낮은 결합도 + 유지보수의 편리) 
  * 조상타입의 배열을 선언하면 자손클래스 객체를 배열에 저장해서 사용할 수 있음.

## 다형성 & 형변환
  * 형변환 전제조건 : 상속, 구현관계(Interface)에 있는 것만 객체타입 변환이 가능(중요)
  * 자손타입 -> 조상타입 : Up-Casting, 형변환 생략가능. 접근가능한 멤버개수가 줄어듦
  * 조상타입 -> 자손타입 : Down-Casting, 형변환 생략불가. 접근가능한 멤버개수가 많아짐

### instanceof 연산자 -> 참조변수가 특정 타입으로 형변환이 가능한지 알아볼 수 있음
  ```
  SportCar sportCar = new SportCar();
  
  if (sportCar instanceof SportCar) { }
  if (sportCar instanceof Car) { }
  ```
## Vector Class
  * Collection framework의 List 계열 (Vector 외에도 ArrayList, LinkedList, Stack 등이 있음)
  * 모든 종류의 객체를 저장할 수 있음
  ```
  Vector vector = new Vector() // 기본적으로는 10개의 객체를 저장할 수 있는 Vector 인스턴스가 생성되고 그 이상을 추가하면 자동으로 크기가 증가한다.
                               // 자세히는 사이즈 증가된 배열을 복사 생성해서 그 배열을 참조하도록 하는 것(자세한건 추후에 Collection 공부할때 설명)
  Object o = new Object()                             
  vector.add(o) // add()로 추가
  Object o = vector.get(0) // get(int index)로 객체 get
  vector.remove(o) // remove()로 삭제
  if (vector.isEmpty()) {} 
  int size = vector.size()
  ```
  
## 

  
  
  
 
 
